import numpy                     as np
import nkUtilities.equiSpaceGrid as esg

# ------------------------------------------------- #
# --- [1] parameters                            --- #
# ------------------------------------------------- #

mmode       = 1
nmode       = 0
freq        = 2.856e9
wg_a        = 0.2
wg_b        = 0.1
wg_c        = 1.0
tMax        = 10.0
LI          = 51
LJ          = 51
LK          = 51
LT          = 101
omega       = 2.0 * np.pi * freq
mu          = 4.0*np.pi*1e-7
cv          = 3.0e8
Hmn         = 1.0


# ------------------------------------------------- #
# --- [2] grid making                           --- #
# ------------------------------------------------- #

x1MinMaxNum = [ 0.0, wg_a, LI ]
x2MinMaxNum = [ 0.0, wg_b, LJ ]
x3MinMaxNum = [ 0.0, wg_c, LK ]
grid        = esg.equiSpaceGrid( x1MinMaxNum=x1MinMaxNum, x2MinMaxNum=x2MinMaxNum, \
                                 x3MinMaxNum=x3MinMaxNum, returnType = "structured" )
xg          = grid[...,0]
yg          = grid[...,1]
zg          = grid[...,2]
time        = np.linspace( 0.0, tMax, LT )

k0          = omega / cv
kx          = mmode * np.pi / wg_a
ky          = nmode * np.pi / wg_b
kc          = np.sqrt( kx**2 + ky**2 )
beta        = np.sqrt( k0**2 - kc**2 )

print( " omega  :: {0}".format( omega ) )
print( " k0     :: {0}".format( k0    ) )
print( " kx     :: {0}".format( kx    ) )
print( " ky     :: {0}".format( ky    ) )
print( " kc     :: {0}".format( kc    ) )
print( " beta   :: {0}".format( beta  ) )

wt          = omega * time[0]
kxx         = kx * xg
kyy         = ky * yg
exp_wt_bz_r = np.cos( wt - beta*zg )
exp_wt_bz_i = np.sin( wt - beta*zg )

# ------------------------------------------------- #
# --- [3] TE mode wave                          --- #
# ------------------------------------------------- #

Ez_Amp      = 0.0   * xg 
Hz_Amp      =                           Hmn * np.cos( kxx ) * np.cos( kyy ) * exp_wt_bz_r

Ex_Amp      = omega * ky * mu / kc**2 * Hmn * np.cos( kxx ) * np.sin( kyy ) * exp_wt_bz_r
Ey_Amp      = omega * kx * mu / kc**2 * Hmn * np.sin( kxx ) * np.cos( kyy ) * exp_wt_bz_r
Hx_Amp      =  beta * kx      / kc**2 * Hmn * np.sin( kxx ) * np.cos( kyy ) * exp_wt_bz_r
Hy_Amp      =  beta * ky      / kc**2 * Hmn * np.cos( kxx ) * np.sin( kyy ) * exp_wt_bz_r

# ------------------------------------------------- #
# --- [4] colormap of the Amplitude             --- #
# ------------------------------------------------- #

import nkVTKRoutines.vtkDataConverter as vdc

Data        = np.zeros( (LK,LJ,LI,9) )
Data[...,0] = xg
Data[...,1] = yg
Data[...,2] = zg
Data[...,3] = Ex_Amp
Data[...,4] = Ey_Amp
Data[...,5] = Ez_Amp
Data[...,6] = Hx_Amp
Data[...,7] = Hy_Amp
Data[...,8] = Hz_Amp

cvt1        = vdc.vtkDataConverter( vtkFile="out.vts", Data=Data, \
                                    tag="data", DataType="structured" )

xp = np.ravel( xg[0,:,:] )
yp = np.ravel( yg[0,:,:] )

print( Hz_Amp.shape )

import nkUtilities.cMapTri as cmt
cmt.cMapTri( xAxis=xp, yAxis=yp, cMap=np.ravel( Hz_Amp[0,:,:] ), pngFile="Hz_Amp.png" )
cmt.cMapTri( xAxis=xp, yAxis=yp, cMap=np.ravel( Ex_Amp[0,:,:] ), pngFile="Ex_Amp.png" )
cmt.cMapTri( xAxis=xp, yAxis=yp, cMap=np.ravel( Ey_Amp[0,:,:] ), pngFile="Ey_Amp.png" )
cmt.cMapTri( xAxis=xp, yAxis=yp, cMap=np.ravel( Hx_Amp[0,:,:] ), pngFile="Hx_Amp.png" )
cmt.cMapTri( xAxis=xp, yAxis=yp, cMap=np.ravel( Hy_Amp[0,:,:] ), pngFile="Hy_Amp.png" )
