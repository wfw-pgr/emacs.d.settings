import numpy         as np
import scipy.spatial as spa


# ========================================================= #
# ===  interpolation via delaunay triangulation         === #
# ========================================================= #

def interpolate__triangulated( Data=None, points=None, method="linear", dim=2 ):

    print( Data.shape )
    print( points.shape )

    if ( dim == 2 ):
        grid    = Data  [:,0:2]
        points2 = points[:,0:2]
    
    delaunay = spa.Delaunay( grid )
    print( delaunay.simplices.shape )
    print( max( delaunay.find_simplex( points2 ) ) )
    
    ret = np.zeros( (points.shape[0],3) )
    return( ret )


# ========================================================= #
# ===   実行部                                          === #
# ========================================================= #

if ( __name__=="__main__" ):
    import nkUtilities.genArgs as gar
    args    = gar.genArgs()

    # ------------------------------------------------- #
    # --- [1] grid data making                      --- #
    # ------------------------------------------------- #
    
    import nkUtilities.equiSpaceGrid as esg
    x1MinMaxNum = [ -1.0, 1.0, 21 ]
    x2MinMaxNum = [ -1.0, 1.0, 21 ]
    grid        = esg.equiSpaceGrid( x1MinMaxNum=x1MinMaxNum, x2MinMaxNum=x2MinMaxNum, \
                                     returnType = "point" )
    radii       = np.sqrt( grid[:,0]**2 + grid[:,1]**2 )
    index       = np.where( radii < 1.0 )
    grid        = grid [index]
    radii       = radii[index]
    height      = ( np.cos( 0.5*np.pi*radii ) )**2
    gData       = np.concatenate( [grid,np.reshape( height, (-1,1))], 1 )

    # ------------------------------------------------- #
    # --- [2] point data making                     --- #
    # ------------------------------------------------- #
    
    nPoints     = 1001
    points      = ( 1.0 - ( -1.0 ) ) * np.random.rand( nPoints, 2 ) + ( -1.0 ) 
    radii       = np.sqrt( points[:,0]**2 + points[:,1]**2 )
    index       = np.where( radii < 1.0 )
    points      = points[index]

    # ------------------------------------------------- #
    # --- [3] interpolation                         --- #
    # ------------------------------------------------- #

    interpolate__triangulated( Data=gData, points=points )
