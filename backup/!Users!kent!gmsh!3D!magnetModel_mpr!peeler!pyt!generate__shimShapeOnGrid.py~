import numpy          as np
import scipy.optimize as opt

# ========================================================= #
# ===  generate 3D profile of shim shape on Grid        === #
# ========================================================= #
def generate__shimShapeOnGrid( r1=0.6, r2=0.7, z1=0.05, z2=0.02, th1=280.0, th2=320.0, \
                               LI=101, LJ=101, outFile="dat/grid.dat" ):

    # ------------------------------------------------- #
    # --- [1] grid making                           --- #
    # ------------------------------------------------- #
    if ( th1 > 180.0 ): th1 = th1 - 360.0
    if ( th2 > 180.0 ): th2 = th2 - 360.0
    
    th1_rad  = th1 / 180.0 * np.pi
    th2_rad  = th2 / 180.0 * np.pi
    
    vertex1  = [ r1*np.cos( th1_rad ), r1*np.sin( th1_rad ) ]
    vertex2  = [ r1*np.cos( th2_rad ), r1*np.sin( th2_rad ) ]
    vertex3  = [ r2*np.cos( th2_rad ), r2*np.sin( th2_rad ) ]
    vertex4  = [ r2*np.cos( th1_rad ), r2*np.sin( th1_rad ) ]

    xMin     = np.min( [ vertex1[0], vertex2[0], vertex3[0], vertex4[0] ] )
    xMax     = np.max( [ vertex1[0], vertex2[0], vertex3[0], vertex4[0] ] )
    yMin     = np.min( [ vertex1[1], vertex2[1], vertex3[1], vertex4[1] ] )
    yMax     = np.max( [ vertex1[1], vertex2[1], vertex3[1], vertex4[1] ] )
    
    import nkUtilities.equiSpaceGrid as esg
    x1MinMaxNum = [ xMin, xMax, LI ]
    x2MinMaxNum = [ yMin, yMax, LJ ]
    x3MinMaxNum = [  0.0,  0.0,  1 ]
    coord       = esg.equiSpaceGrid( x1MinMaxNum=x1MinMaxNum, x2MinMaxNum=x2MinMaxNum, \
                                     x3MinMaxNum=x3MinMaxNum, returnType = "point" )

    # ------------------------------------------------- #
    # --- [2] generate shimShape on Grid            --- #
    # ------------------------------------------------- #

    functionType = "fitted"
    
    if ( functionType == "sin2" ):
    
        rhat        = ( ( np.sqrt( coord[:,0]**2 + coord[:,1]**2 ) - r1 ) / ( r2-r1 )  )
        thhat       = ( np.arctan2( coord[:,1], coord[:,0] ) - th1_rad ) / ( th2_rad - th1_rad )
        
        coord[:,2]  = ( z2-z1 ) * rFunc( rhat ) * thFunc( thhat ) + z1
        nouse_index = np.where( ( rhat < 0.0 ) | ( rhat > 1.0 ) | ( thhat < 0.0 ) | ( thhat > 1.0 ) )
        ( coord[:,2] )[nouse_index] = z1

    if ( functionType == "fitted" ):

        rhat        = ( ( np.sqrt( coord[:,0]**2 + coord[:,1]**2 ) - r1 ) / ( r2-r1 )  )
        thhat       = ( np.arctan2( coord[:,1], coord[:,0] ) - th1_rad ) / ( th2_rad - th1_rad )
        
        coef_r      = obtain_fit( inpFile="dat/outline_r.conf" )
        coef_t      = obtain_fit( inpFile="dat/outline_t.conf" )

        Func_r      = quarticEquation( rhat , coef_r[0], coef_r[1], coef_r[2], \
                                       coef_r[3], coef_r[4] )
        Func_t      = quarticEquation( thhat, coef_t[0], coef_t[1], coef_t[2], \
                                       coef_t[3], coef_t[4] )
        Func_r[np.where( Func_r > 1.0 )] = 1.0
        Func_r[np.where( Func_r < 0.0 )] = 0.0
        Func_t[np.where( Func_t > 1.0 )] = 1.0
        Func_t[np.where( Func_t < 0.0 )] = 0.0
        
        coord[:,2]  = ( z2-z1 ) * Func_r * Func_t + z1
        nouse_index = np.where( ( rhat < 0.0 ) | ( rhat > 1.0 ) | ( thhat < 0.0 ) | ( thhat > 1.0 ) )
        ( coord[:,2] )[nouse_index] = z1

        with open( "dat/coef_Func_r.dat", "w" ) as f:
            np.savetxt( f, coef_r )
        with open( "dat/coef_Func_t.dat", "w" ) as f:
            np.savetxt( f, coef_t )
        
        import nkUtilities.cMapTri as cmt
        pngFile = "png/fitprofile.png"
        cmt.cMapTri( xAxis=coord[:,0], yAxis=coord[:,1], cMap=coord[:,2], pngFile=pngFile )
        

    # ------------------------------------------------- #
    # --- [3] output text File                      --- #
    # ------------------------------------------------- #
    import nkUtilities.save__pointFile as spf
    outFile   = "dat/grid.dat"
    spf.save__pointFile( outFile=outFile, Data=coord, names=["x","y","z"], shape=(LJ,LI,3) )
    
    # ------------------------------------------------- #
    # --- [4] output figure                         --- #
    # ------------------------------------------------- #
    import nkUtilities.cMapTri    as cmt
    import nkUtilities.LoadConfig as lcf
    config = lcf.LoadConfig()
    config["cmp_xAutoRange"] = True
    config["cmp_yAutoRange"] = True
    config["cmp_xRange"]     = [ 0.0, 1.0]
    config["cmp_yRange"]     = [-1.0, 0.0]
    config["cmp_AutoLevel"]  = False
    config["cmp_MaxMin"]     = [0.010, 0.060]
    fig    = cmt.cMapTri( pngFile="png/grid.png", config=config )
    fig.add__cMap( xAxis=coord[:,0], yAxis=coord[:,1], cMap=coord[:,2] )
    peri_x = [ vertex1[0], vertex2[0], vertex3[0], vertex4[0], vertex1[0] ]
    peri_y = [ vertex1[1], vertex2[1], vertex3[1], vertex4[1], vertex1[1] ]
    fig.add__plot( xAxis=peri_x, yAxis=peri_y, linestyle="--", color="Green" )
    fig.set__colorBar()
    fig.save__figure()


    
# ========================================================= #
# ===  Function of r ( R(r) )                           === #
# ========================================================= #
def rFunc( rhat ):
    # coef = [ 0.0, -1.0, +1.0, +0.75 ]
    # ret  = coef[0]*rhat**3 + coef[1]*rhat**2 + coef[2]*rhat + coef[3]
    plateu  = 0.40
    hplateu = plateu*0.5
    if   ( rhat <= ( 0.5-hplateu ) ):
        ret  = ( np.sin( rhat/hplateu * np.pi *0.5 ) )**2
    elif ( rhat >= ( 1.0-hplateu ) ):
        ret  = ( np.sin( ( rhat-(1.0-hplateu) ) / hplateu * np.pi *0.5 ) )**2
    return( ret )
    

# ========================================================= #
# ===  Function of theta ( THETA(theta) )               === #
# ========================================================= #
def thFunc( thhat ):
    ret  = ( np.sin( thhat*np.pi ) )**2
    return( ret )


# ========================================================= #
# ===  quartic equation                                 === #
# ========================================================= #
def quarticEquation( xval, c1, c2, c3, c4, c5 ):
    yval       = c1 * xval**4 + c2 * xval**3 \
        +        c3 * xval**2 + c4 * xval    + c5
    return( yval )


def obtain_fit( inpFile=None ):

    # ------------------------------------------------- #
    # ---  curve fitting                            --- #
    # ------------------------------------------------- #

    with open( inpFile, "r" ) as f:
        Data   = np.loadtxt( f )
    xval       = Data[:,0]
    yval       = Data[:,1]
    cOpt,mCov  = opt.curve_fit( quarticEquation, xval, yval )

    nSample    = 101
    xval_      = np.linspace( xval[0], xval[-1], nSample ) 
    yval_      = quarticEquation( xval_, cOpt[0], cOpt[1], cOpt[2], cOpt[3], cOpt[4] )

    # ------------------------------------------------- #
    # ---  plot Figure                              --- #
    # ------------------------------------------------- #
    import nkUtilities.plot1D         as pl1
    pngFile = ( inpFile.replace( "dat", "png" ) ).replace( ".conf", ".png" )
    fig = pl1.plot1D( pngFile=pngFile )
    fig.add__plot( xAxis=xval , yAxis=yval , label="raw" )
    fig.add__plot( xAxis=xval_, yAxis=yval_, label="fit" )
    fig.add__legend()
    fig.set__axis()
    fig.save__figure()
    print()
    print( "[set__sampleShape] coefficients :: {0}".format( cOpt    ) )
    print()

    return( cOpt )



# ======================================== #
# ===  実行部                          === #
# ======================================== #
if ( __name__=="__main__" ):
    generate__shimShapeOnGrid()



# # ========================================================= #
# # ===  obtain__fittedEquation                           === #
# # ========================================================= #

# def obtain__fittedEquation():

#     # ------------------------------------------------- #
#     # ---  curve fitting                            --- #
#     # ------------------------------------------------- #

#     inpFile_r  = "dat/outline_r.dat"
#     inpFile_t  = "dat/outline_t.dat"

#     with open( inpFile_r, "r" ) as f:
#         rData  = np.loadtxt( f )
#     with open( inpFile_t, "r" ) as f:
#         tData  = np.loadtxt( f )
        
#     cOpt_r,cov = opt.curve_fit( quarticEquation, rData[:,0], rData[:,1] )
#     cOpt_t,cov = opt.curve_fit( quarticEquation, tData[:,0], tData[:,1] )

#     nSample    = 101
#     xval_r     = np.linspace( rData[0,0], rData[-1,0], nSample ) 
#     yval_r     = quarticEquation( xval_r   , cOpt_r[0], cOpt_r[1], \
#                                   cOpt_r[2], cOpt_r[3], cOpt_r[4] )
#     xval_t     = np.linspace( tData[0,0], tData[-1,0], nSample ) 
#     yval_t     = quarticEquation( xval_t   , cOpt_t[0], cOpt_t[1], \
#                                   cOpt_t[2], cOpt_t[3], cOpt_t[4] )

#     # ------------------------------------------------- #
#     # ---  plot Figure                              --- #
#     # ------------------------------------------------- #
#     import nkUtilities.plot1D         as pl1
#     pngFile = "png/outline_r.png"
#     fig = pl1.plot1D( pngFile=pngFile )
#     fig.add__plot( xAxis=rData[:,0], yAxis=rData[:,1], label="raw" )
#     fig.add__plot( xAxis=xval_r    , yAxis=yval_r    , label="fit" )
#     fig.add__legend()
#     fig.set__axis()
#     fig.save__figure()
#     print()
#     print( "[set__sampleShape] coefficients (radii) :: {0}".format( cOpt_r ) )
#     print()

    
#     pngFile = "png/outline_t.png"
#     fig = pl1.plot1D( pngFile=pngFile )
#     fig.add__plot( xAxis=tData[:,0], yAxis=tData[:,1], label="raw" )
#     fig.add__plot( xAxis=xval_t    , yAxis=yval_t    , label="fit" )
#     fig.add__legend()
#     fig.set__axis()
#     fig.save__figure()
#     print()
#     print( "[set__sampleShape] coefficients (theta) :: {0}".format( cOpt_t ) )
#     print()

#     return( (cOpt_r,cOpt_t) )

