import numpy                    as np

# ========================================================= #
# ===  prepare__weight.py                               === #
# ========================================================= #

def prepare__weight():

    x_, y_, z_  = 0, 1, 2 
    c_, w_, f_  = 3, 4, 5
    
    # ------------------------------------------------- #
    # --- [1] load point File / constants           --- #
    # ------------------------------------------------- #
    # import nkMDTRoutines.get__jobinfo as gji
    # info      = gji.get__jobinfo()
    # const     = info["config"]
    import nkUtilities.load__constants as lcn
    const     = lcn.load__constants( inpFile="dat/unified.conf" )
    
    
    import nkUtilities.load__pointFile as lpf
    inpFile1  = "dat/bfield_input.dat"
    inpFile2  = "dat/mshape_input.dat"
    bfield    = lpf.load__pointFile( inpFile=inpFile1, returnType="point" )
    mshape    = lpf.load__pointFile( inpFile=inpFile2, returnType="point" )
    
    index     = np.where( np.array( mshape[:,f_], dtype=np.int ) == 1 )
    mshape    = mshape[index]
    
    # ------------------------------------------------- #
    # --- [2] coloring / weighting                  --- #
    # ------------------------------------------------- #

    if   ( const["w_mode"] is None ):
        const["w_mode"] = "None"
    
    if   ( const["w_mode"].lower() == "constant"    ):
        weight = weight__constant   ( bfield=bfield, mshape=mshape, const=const )        

    elif ( const["w_mode"].lower() == "distributed" ):
        weight = weight__distributed( bfield=bfield, mshape=mshape, const=const )

    elif ( const["w_mode"].lower() == "none"        ):
        print( "[prepare__weight] w_mode == None. >> Nothing to do. " )
        return()
        
    else:
        print( "[prepare__weight] w_mode == ?? :: {0}".format( const["w_mode"] ) )
        sys.exit()

    ncolor = ik
    print( "[prepare__weight] ncolor = {0} ".format( ncolor ) )
        
    # ------------------------------------------------- #
    # --- [3] save in File                          --- #
    # ------------------------------------------------- #
    import nkUtilities.save__pointFile as spf
    outFile   = "dat/weights.dat"
    spf.save__pointFile( outFile=outFile, Data=weights )


    # ------------------------------------------------- #
    # --- [4] contour out                           --- #
    # ------------------------------------------------- #
    
    #  -- [4-1] config call & settings              --  #
    import nkUtilities.cMapTri as cmt
    import nkUtilities.load__config as lcf
    pngFile                 = "png/weight_{0:02}.png"
    config                  = lcf.load__config()
    config["cmp_AutoLevel"] = True
    config["cmp_MaxMin"]    = [0.0,0.020]

    #  -- [4-2] draw figure                         --  #
    for ic in range( ncolor+1 ):
        index = np.where( weights[    :,c_] == float( ic+1 ) )
        xAxis = np.ravel( weights[index,x_] )
        yAxis = np.ravel( weights[index,y_] )
        cMap  = np.ravel( weights[index,w_] )
        cmt.cMapTri( xAxis=xAxis, yAxis=yAxis, cMap=cMap, \
                     config=config, pngFile=pngFile.format( ic+1 ) )
    return()


# ========================================================= #
# ===  constant weight settings                         === #
# ========================================================= #

def weight__constant( bfield=None, mshape=None, const=None ):

    eps         = 1.e-5
    x_, y_, z_  = 0, 1, 2 
    c_, w_, f_  = 3, 4, 5

    # ------------------------------------------------- #
    # --- [1] Arguments / Preparation               --- #
    # ------------------------------------------------- #
    if ( bfield is None ): sys.exit( "[weight__distributed] bfield == ???" )
    if ( mshape is None ): sys.exit( "[weight__distributed] mshape == ???" )
    if ( const  is None ): sys.exit( "[weight__distributed] const  == ???" )
    
    i1, i2, ik  = 0, 0, 0
    nBpt,nMpt   = bfield.shape[0], mshape.shape[0]
    nNpt        = nBpt + nMpt
    nItems      = [nBpt,nMpt]
    weights     = np.zeros( ( nNpt,5 ) )
    color_count = 1
    
    # ------------------------------------------------- #
    # --- [2] 1st region ( field weight )           --- #
    # ------------------------------------------------- #
    i1                = i2
    i2                = i2 + nItems[ik]
    weights[i1:i2,x_] = bfield[:,x_]
    weights[i1:i2,y_] = bfield[:,y_]
    weights[i1:i2,z_] = bfield[:,z_]
    weights[i1:i2,c_] = color_count
    weights_          = np.zeros( (nItems[ik],) )
    colors_           = np.zeros( (nItems[ik],) )
    radii             = np.ravel( np.sqrt( bfield[:,x_]**2 + bfield[:,y_]**2 ) )
    index1            = np.where( radii <= const["svd.rLim1"] + eps )
    index2            = np.where( radii  > const["svd.rLim1"] + eps )
    weights_[index1]  = const["svd.weight.main"]
    weights_[index2]  = const["svd.weight.fringe"]
    colors_[index1]   = color_count
    colors_[index2]   = color_count + 1
    weights[i1:i2,w_] = weights_
    weights[i1:i2,c_] = colors_
    ik                = ik + 1
    color_count       = color_count + 2

    # ------------------------------------------------- #
    # --- [3] 2nd region ( shape weight )           --- #
    # ------------------------------------------------- #
    i1                = i2
    i2                = i2 + nItems[ik]
    weights[i1:i2,x_] = mshape[:,x_]
    weights[i1:i2,y_] = mshape[:,y_]
    weights[i1:i2,z_] = mshape[:,z_]
    # -- color / weights -- #
    weights[i1:i2,c_] = color_count
    weights[i1:i2,w_] = const["svd.weight.shape"]
    ik                = ik + 1
    color_count       = color_count + 1
    return( weights )


# ========================================================= #
# ===  distributed case routine                         === #
# ========================================================= #

def weight__distributed( bfield=None, mshape=None, const=None ):

    x_, y_, z_  = 0, 1, 2 
    c_, w_, f_  = 3, 4, 5

    # ------------------------------------------------- #
    # --- [1] Arguments / Preparation               --- #
    # ------------------------------------------------- #
    if ( bfield is None ): sys.exit( "[weight__distributed] bfield == ???" )
    if ( mshape is None ): sys.exit( "[weight__distributed] mshape == ???" )
    if ( const  is None ): sys.exit( "[weight__distributed] const  == ???" )
    
    i1, i2, ik  = 0, 0, 0
    nBpt,nMpt   = bfield.shape[0], mshape.shape[0]
    nNpt        = nBpt + nMpt
    nItems      = [nBpt,nMpt]
    weights     = np.zeros( ( nNpt,5 ) )
    coef_F      = const["svd.weight.dist_coef_F"]
    coef_S      = const["svd.weight.dist_coef_S"]
    
    # ------------------------------------------------- #
    # --- [2]  1st region ( field weight )          --- #
    # ------------------------------------------------- #
    i1                = i2
    i2                = i2 + nItems[ik]
    weights[i1:i2,x_] = bfield[:,x_]
    weights[i1:i2,y_] = bfield[:,y_]
    weights[i1:i2,z_] = bfield[:,z_]
    weights[i1:i2,c_] = ik + 1
    weights[i1:i2,w_] = distFunc__01( bfield[:,x_], bfield[:,y_], coef_F[0], coef_F[1], \
                                      coef_F[2], coef_F[3], coef_F[4] )
    ik                = ik + 1
    
    # ------------------------------------------------- #
    # --- [3]  2nd region ( shape weight )          --- #
    # ------------------------------------------------- #
    i1                = i2
    i2                = i2 + nItems[ik]
    weights[i1:i2,x_] = mshape[:,x_]
    weights[i1:i2,y_] = mshape[:,y_]
    weights[i1:i2,z_] = mshape[:,z_]
    weights[i1:i2,c_] = ik + 1
    weights[i1:i2,w_] = distFunc__01( mshape[:,x_], mshape[:,y_], coef_S[0], coef_S[1], \
                                      coef_S[2], coef_S[3], coef_S[4] )
    ik                = ik + 1
    return( weights )


# ========================================================= #
# ===  distribution Function                            === #
# ========================================================= #

def distFunc__01( xpos, ypos, xc, yc, c1, c2, c3 ):

    radiisq = ( xpos - xc )**2 + ( ypos-yc )**2
    coef    =   0.5 / c3**2
    ret     = ( c1-c2 ) * np.exp( - coef * radiisq ) + c2
    return( ret )


# ========================================================= #
# ===   実行部                                          === #
# ========================================================= #
if ( __name__=="__main__" ):
    prepare__weight()
