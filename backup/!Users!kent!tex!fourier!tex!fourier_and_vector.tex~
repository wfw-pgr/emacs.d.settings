\section{基底関数展開}

\subsection{空間座標をベクトルで表す（普通のベクトル）}

まず、空間座標とベクトルについて、おさらいしておく．
めちゃめちゃ簡単な問題として、平面上の点をベクトルで表すことを考える．
とある空間座標(3,4)の表し方は基底となる方向（基底ベクトル: $\hat{e_1}, \hat{e_2}$）を選んで、

\begin{align}
  \bvec{a} = (3,4) = 3 \hat{e_1} + 4 \hat{e_2} = \sum_{i=1}^2 a_i \hat{e_i}
\end{align}

と表す．ここでは、$\hat{e_1}=\hat{x}, \hat{e_2}=\hat{y}$として選んでる．つまり、x成分が３で、y成分が４だということ．これは至極当然だけど、勿論、平行四辺形を作るようなベクトル二本を使って表すことも可能である．ベクトルの大きさが１であり、$\hat{e_1}, \hat{e_2}$が互いに干渉しないような基底は、正規直交基底という．

ある空間座標系を、とある基底の組を用いて表すには、その基底への射影を取れば良い．

\begin{align}
  \bvec{a} &= (\bvec{a},\hat{e_1}) \hat{e_1} + (\bvec{a},\hat{e_2}) \hat{e_2} \\
           &= \sum_{i=1}^2 (\bvec{a},\hat{e_i}) \hat{e_i}
\end{align}

ここで、$(\bvec{u},\bvec{v})$は、ベクトル $\bvec{u},\bvec{v}$の内積である．

上記は、空間座標をある基底ベクトルの組を選んできて、成分を計算するだけである．

\begin{figure}[htb]
  \centering
  \includegraphics[width=7cm,clip]{png/vector2D}
  \caption{２次元平面の基底ベクトル展開の例．x成分3、y成分4という値で、２次元面内の点を表すのも立派な基底ベクトル展開．}
\end{figure}


\subsection{基底関数展開とは何か？なんで分解するのか？}
基底関数展開とは、ある関数を別の関数の線形結合として表現することである．

\begin{align}
  y(x) = a_1 u_1 (x) + a_2 u_2(x) + \cdots + a_N u_N(x) = \sum_{i=1}^N a_i u_i(x)
\end{align}

これは、結局、y(x)の成分は、1.5倍の$u_1$の成分と、1.2倍の$u_2$の成分と、....、みたいに基本成分毎に分解して表示しているだけ．ちょうど、空間座標を、いくつかのベクトルを使って成分表示するようなものである．

基底関数展開を例えると、有村架純の顔を、堀北真希成分0.7と長澤まさみ成分0.2と北川景子成分0.4に分解して表現する、みたいな感じ．基底関数は、好きに選んで良くて、北川景子じゃなくて、沢尻エリカと北乃きいを基底にとっても全く問題ない．

但し、例えば3次元空間(x,y,z)上のベクトルを2次元空間(x,y)上のベクトル3本に分解して表現しようとするなど、そもそも表現できない基底関数を用いるのはだめ．これは、有村架純を光浦さんと大久保さんと渡辺直美に成分分解しようとするようなもの．この３人をいくら足したり引いたりしても有村架純の顔は作れない．

関数展開をするのは、

\begin{enumerate}
\item 簡単な基底関数を使えば計算が楽になったり、
\item どの基底関数成分が主要なのか、などなど、わかったり、
\item いらない成分を落として簡単な近似関数にできたり
\item 微積（ほかの線形演算でも！）のとき、成分毎に分けて考えられる etc.
\end{enumerate}

などなど、いろんなメリットがあるから．


\subsection{基底関数展開のイメージと例}

基底関数展開は、部分毎に関数を貼り合わせるイメージ．
例えば、筑波山の包絡線をガウシアンを縦横に伸縮、横に平行移動させた分布を複数重ね合わせて再現してください、みたいな問題について考えるような感じ．とある山を幅とか中心位置が違うガウシアンN本使ってフィッティングするような感じ．

\begin{figure}[htb]
  \centering
  \includegraphics[width=10cm,clip]{png/basisfunc_decomposition.png}
  \caption{筑波山をガウシアンに分解してみる．意味はないけど．}
\end{figure}


一番簡単で特殊な基底関数展開の例としては、デルタ関数がある．
デルタ関数をある関数にかけて積分を取れば、よく知られているように、
\begin{align}
  f(a) = \int_{-\infty}^{\infty} f(x) \delta(x-a) dx
\end{align}
となる．これは、サンプリング関数（デルタ関数）を使ってある関数のある時間の値をサンプリングして（切り取って）いくのに等価．これは文字を書き換えただけで、次のようにデルタ関数による基底関数展開として眺めることができる．

\begin{align}
  f(x) = \int f(x^\prime) \delta(x^\prime-x) dx^\prime
\end{align}

デルタ関数で$f(x^\prime)$をぶつぶつに切っていって、それを全部集めたら元の関数になる．
これは、ある関数を、無限に薄い（幅の狭い）短冊上に切っていって、あとで貼り合わし直すようなイメージ．

\begin{figure}[htb]
  \centering
  \includegraphics[width=10cm,clip]{png/delta_decomposition.png}
  \caption{ある関数をデルタ関数の基底関数で表現するイメージ．サンプリングと同じ．}
\end{figure}


\subsection{関数とベクトル}

関数は無限次元のベクトルである．このイメージについて、次に大雑把に説明する．

関数$y=f(x)$は、入力変数$x$から出力値$y$を計算する手続きを指す．では、無限個の入力値$x=[-\infty,\infty]$に対して、全ての対応する$y$の値を記録した数表があったら？ つまりこれは関数$y=f(x)$のグラフの値を全部覚えている(記録している)ベクトルということ．プログラミングしている人は簡単にイメージつくと思う．区間[0,1]の、長さ100000000000000000の等間隔区切りしたベクトル$x$を用いて計算した$y$の値とか、もう関数$y=f(x)$とほぼおんなじやん、と思ってくれるはず．無限次元のベクトルは、関数$f(x)$を表しているのと同値と言える．関数は、無限に広い範囲($x=[-\infty,\infty]$)を、無限に細かくしていけるので、情報として持つと、情報量無限大の無限次元のベクトルになっちゃう．

\begin{itembox}[c]{少し無理矢理なイメージ付け}
  \centering
  関数は、無限次元のベクトルとして表すことができる．
\end{itembox}

\subsection{関数の内積}
無限次元ベクトルと関数が同値なものであると述べた．だったら、ベクトルにおける内積に相当する演算が、関数にもあるはずである．まず、ベクトルの内積は、勿論、各成分の積を計算して足し合わせたものであり、
\begin{align}
  (\bvec{u},\bvec{v}) =
  \begin{bmatrix}
    u_1 \\ u_2 \\ \vdots \\ u_N
  \end{bmatrix}
  \cdot
  \begin{bmatrix}
    v_1 \\ v_2 \\ \vdots \\ v_N
  \end{bmatrix}
  =
  \begin{bmatrix}
    u_1 \\ u_2 \\ \vdots \\ u_N
  \end{bmatrix}
  ^{T}
  \begin{bmatrix}
    v_1 \\ v_2 \\ \vdots \\ v_N
  \end{bmatrix}
  = \sum_{i=1}^{N} u_i v_i
\end{align}
とかける．

これを無限次元ベクトル、つまり関数に拡張すると、関数の内積は
\begin{align}
  (f(x),g(x)) =
  \begin{bmatrix}
    f_1 \\ f_2 \\ \vdots \\ f_\infty
  \end{bmatrix}
  \cdot
  \begin{bmatrix}
    g_1 \\ g_2 \\ \vdots \\ g_\infty
  \end{bmatrix}
  =
  \begin{bmatrix}
    u_1 \\ u_2 \\ \vdots \\ u_N
  \end{bmatrix}
  ^{T}
  \begin{bmatrix}
    v_1 \\ v_2 \\ \vdots \\ v_N
  \end{bmatrix}
  = \sum_{i=1}^{\infty} f_i g_i
\end{align}
とかける（無限次元に拡張しただけ）．これは、より正しくは積分を使って、
\begin{align}
  (f(x),g(x)) = \int_{-\infty}^{\infty} f(x) g(x) dx
\end{align}
と、連続関数の全領域の積分として書くことができる．これが関数の内積である．

あとで出てくるけども、複素数を含む場合には、注意が必要である．
複素数を含んだベクトルの内積は、ベクトルの転置だけ出なくて、複素共役もとる（エルミート共役）．これは、複素数のとき、内積の値が実数となるようにするための定義である．
\begin{align}
  (\bvec{u},\bvec{v}) =
  \begin{bmatrix}
    u_1 \\ u_2 \\ \vdots \\ u_N
  \end{bmatrix}
  \cdot
  \begin{bmatrix}
    v_1 \\ v_2 \\ \vdots \\ v_N
  \end{bmatrix}
  =
  \begin{bmatrix}
    u_1 \\ u_2 \\ \vdots \\ u_N
  \end{bmatrix}
  ^{\dagger}
  \begin{bmatrix}
    v_1 \\ v_2 \\ \vdots \\ v_N
  \end{bmatrix}
  = \sum_{i=1}^{N} u_i v_i
\end{align}
ここで記号$\dagger$はエルミート共役を意味する．こうしておくと、

\begin{align}
  (\bvec{v},\bvec{v}) = \bvec{v}^{\dagger} \bvec{v} = |\bvec{v}|^2 
\end{align}
と同じものの内積が距離の２乗になって都合が良い．逆にエルミート共役としなければ、あるベクトルの自分との内積が複素数になってしまってすごくバランスが悪い．なので、複素数ベクトルの内積はエルミート共役を使う．

これに倣って、複素数関数の内積は、以下に示すように複素共役をとることになる．

\begin{align}
  (f(x),g(x)) = \int_{-\infty}^{\infty} f(x) \overline{ g(x) } dx
\end{align}



\subsection{基底関数展開とベクトル代数}

関数と無限次元ベクトルが同値であるというイメージができれば、基底関数展開とは、基底ベクトル展開を無限次元の大きさでやっているだけということに気づく．関数$f(x)$を表す無限次元ベクトル$\bvec{a}$として、ベクトル代数からみた基底関数展開を無理矢理表記することを考える．細かい証明とか勿論すっ飛ばすので、上式とのアナロジーから類推して欲しいが、基底関数を$\phi_i(x)$としたときの関数$f(x)$の基底関数展開は下式である．
\begin{align}
  \bvec{a} = \sum_{i=1}^N (\bvec{a},\hat{e_i}) \hat{e_i} \ \ \  \Leftrightarrow \ \ \
  f(x) =  \sum_{i=1}^{N} ( f(x), \phi_i(x) ) \phi_i(x)  
\end{align}
ベクトルの式は、これまでと同様に、無限次元ベクトルの無限個の次元それぞれにおいて、各方向($x,y,z,w,...$)の大きさはどんなものであるか、を測っているだけである．
関数の場合も、これと同様に、i番目の基底関数$\phi_i(x)$と$f(x)$との内積をとって（射影=$\phi_i(x)$関数空間上の長さ=$\phi_i(x)$関数空間上の成分強さ=スペクトル、を求めて）、それの成分表示したものである．やっていることはなんら変わりない．

上記はイメージであるが、より正確に一般的に書くとする．有限本数の基底関数の重ね合わせだと限界が生じるので、連続関数を表現するために無限に細かい関数空間（微妙に違う基底関数を無限本使って）、ものすごく細かな関数の変化を表現できるような表記にすると、以下になる．
\begin{align}
  f(x) =  \int_{-\infty}^{\infty} ( f(x), \phi_i(x) ) \phi_i(x) d\phi
\end{align}
無限小に微妙に違う基底関数を無限本重ね合わせて、とある関数$f(x)$を表現します、という上での議論と全く変わらないことをいっているだけ．


\subsection{基底関数の選び方}

基底関数をどう選ぶのか、これは、あるベクトルをxyz直交座標で表すのか、円筒座標で表すのか、球座標で表すのか、といった基準選びであって、ちゃんと表せるのであればなんでもよい（勿論、問題によって都合の良い座標系が存在するから、ちゃんと選ぶのであるが）．基底関数展開においても、別に何を使って表そうとも構わないのだけれども、以下のことを考えると、候補は少しずつ絞られてくる．

\begin{enumerate}
\item できれば無限回微積分可能な連続な関数系を使いたい
\item 基底関数として任意の関数を表現するためには、無限本の別々の基底関数が必要
\item 無限の積分範囲を計算するのはめんどい
\end{enumerate}

まず、1番目の連続な関数系を使いたいのは当然．2番目は、関数系を"$f_1(x)=x$, $f_2(x)=2x+1$, $f_3(x)=-x^2+3x+4$, $f_4(x)=x^2-2$,... "などと、逐一考えても勿論良いんだけれども、「本当にあなたは無限本も関数をさっと思いつけますか？」ということ．自動的・機械的にどんどん作っていけた方が圧倒的に楽．簡単に、あんまり他とは被らない微妙に変わっている関数系を、無限本、用意して欲しい．３番目は、積分空間が無限大だと、積分がめんどかったり、そもそも有界な値に治らなかったりするという問題があるため．有限の積分範囲にしても大丈夫な周期関数を要請したい．ねぇ、どらえもん、道具だしてよ．

この辺考えると、自然と、「関数系として何を選ぶのか問題」は三角関数( sin, cos )で良いよねって、普通の人は、第一感に思うはず．無限回微積できるし、波数変えて無限本の基底用意できるし、周期関数だし．なんか違う関数の方がもしかしたら良いんじゃないかとか考えられる元気と強いこだわりがある人はウェーブレットをのぞいて見てください．

\subsection{Fourier積分表示}

脳死、三角関数の人はようこそ．Fourier変換しましょう．
基底関数として、
\begin{align}
  \phi_i(x) = e^{jk_ix}
\end{align}
を考えます．勿論、
\begin{align}
  \phi_i(x) = e^{jk_ix} = cos(kx) + j sin(k_ix)
\end{align}
で三角関数なんだけど、書くのがめんどいので．ここで、jは虚数単位．中の人は電気系出身なので．$k_i$は、i番目の基底関数の波数で、
\begin{align}
  k_i = \dfrac{2 \pi}{N} i
\end{align}
を表す．どんだけ細かく分割したモードを考えている基底関数なのか、ということ．Nは全モード数で、無限大にすっ飛ばすと、無限小に細かく区切った連続的な波数を考えることになります．

これを使って、基底関数展開すると、
\begin{align}
  f(x) =  \int_{-\infty}^{\infty} ( f(x), \phi_i(x) ) \phi_i(x) d\phi
\end{align}
に基底関数  $\phi_i(x) = e^{jk_ix}$を代入して、
\begin{align}
  f(x) =  \dfrac{1}{2\pi} \int_{-\infty}^{\infty} ( f(x), e^{jkx} ) e^{jkx} dk
\end{align}
ここで、無限に細かく分割するので、$k_i \rightarrow k$と有限区間離散から無限小連続に変えてます．

内積の中身は、複素数関数に注意して、複素共役をとってやって、
\begin{align}
  (f(x),e^{jkx}) = \int_{-\infty}^{\infty} f(x^\prime) e^{-jkx^\prime} dx^\prime
\end{align}
とかける．これを代入すると、Fourier積分の式、
\begin{align}
  f(x) =  \dfrac{1}{2\pi} \int_{-\infty}^{\infty}
  \left[ \int_{-\infty}^{\infty} f(x^\prime) e^{-jkx^\prime} dx^\prime \right]
  e^{jkx} dk
\end{align}
へ基底関数展開することができる．

これは勿論、御馴染みの、

\begin{align}
  F(k) =  \int_{-\infty}^{\infty} f(x) e^{-jkx} dx \\
  f(x) =  \dfrac{1}{2\pi} \int_{-\infty}^{\infty} F(k) e^{jkx} dk
\end{align}

として表記でき、上側をFourier変換、下式をFourier逆変換、という．
