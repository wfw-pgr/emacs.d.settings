module lInterp1DMod
contains

  ! ====================================================== !
  ! === linear Interpolation for 1D profile            === !
  ! ====================================================== !
  subroutine linearInterp1D( xa, fa, xp, fp, nData, nIntp, force_to_ )
    implicit none
    integer         , intent(in)  :: nData, nIntp
    double precision, intent(in)  :: xa(nData), fa(nData)
    double precision, intent(in)  :: xp(nData)
    double precision, intent(out) :: fp(nData)
    integer         , intent(in)  :: force_to_
    integer                       :: ik, is, iIni, iFin, iMid
    double precision              :: dxInv, p1, p2
    
    iMid = int( nData / 2 )
    do ik=1, nIntp
       ! ------------------------------------------------------ !
       ! --- [1] boundary value exceptions                  --- !
       ! ------------------------------------------------------ !
       !  -- out-of-range exception :: xp < min(xa)         --  !
       if ( xp(ik).lt.xa(    1) ) then
          if ( force_to_.eq.1 ) then
             xp(ik) = xa(1)
          else
             write(6,*) "xp is out of range :: ik = ", ik, " xp(ik) = ", xp(ik)
             write(6,*) "             range :: xa(1) = ", xa(1), ", xa(nData) = ", xa(nData)
             stop
          endif
       endif
       !  -- out-of-range exception :: xp > max(xa)         --  !
       if ( xp(ik).gt.xa(nData) ) then
          if ( force_to_.eq.1 ) then
             xp(ik) = xa(nData)
          else
             write(6,*) "xp is out of range :: ik = ", ik, " xp(ik) = ", xp(ik)
             write(6,*) "             range :: xa(1) = ", xa(1), ", xa(nData) = ", xa(nData)
             stop
          endif
       endif
       !  -- exact boundary value case ::                   --  !
       if ( xp(ik).eq.xa(nData) ) then
          fp(ik) = fa(nData)
          exit
       endif
       ! ------------------------------------------------------ !
       ! --- [2] search section to be interpolated          --- !
       ! ------------------------------------------------------ !
       !  --  initiarl search position                      --  !
       if ( xp(ik).ge.xa(iMid) ) then
          iIni = iMid
          iFin = nData
       else
          iIni = 1
          iFin = iMid-1
       endif
       !  --  search & interpolate                          --  !
       do is=iIni, iFin
          if ( ( xp(ik).ge.xa(is) ).and.( xp(ik).lt.xa(is+1) ) ) then
             dxInv  = 1.d0 / ( xa(is+1) - xa(is) )
             p1     = ( xa(is+1) - xp(ik) ) * dxInv
             p2     = ( xp(ik  ) - xa(is) ) * dxInv
             fp(ik) = p1*fa(is) + p2*fa(is+1)
             exit
          endif
       enddo
       
    enddo
    
    return
  end subroutine linearInterp1D
  
end module lInterp1DMod
